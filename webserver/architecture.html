
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Web server architecture &#8212; Fractal  documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Web server responsibilities" href="responsibilities.html" />
    <link rel="prev" title="Welcome to Fractal’s documentation!" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="web-server-architecture">
<h1>Web server architecture<a class="headerlink" href="#web-server-architecture" title="Permalink to this headline">¶</a></h1>
<p>When deployed, the so-called “web server” is actually a group of three closely-related services. They are</p>
<ul class="simple">
<li><p>the HTTP server itself,</p></li>
<li><p>an asynchronous task queue, and</p></li>
<li><p>a worker pool.</p></li>
</ul>
<p>Only the HTTP server is accessible to the public. The HTTP server and the worker pool, using the asynchronous task queue as their primary communication channel, work together to process all incoming requests.</p>
<p>Any time the web server receives a request that would take more than a few milliseconds to process, it adds the processing of that request to the asynchronous task queue and immediately returns a unique ID identifying the entry in the queue to the caller (usually the desktop application). The caller can use this unique ID to poll for the tasks’ status while it waits in the queue to be picked up by a worker and while the task is being processed. When the tasks’ processing is complete, the caller can use the unique ID to retrieve the result.</p>
<p>We have chosen to pair a worker pool with our HTTP server in this way to increase the worst-case rate at which our web server can process requests. Since the web server processes each request in its own thread and it is only practical for the web server to spawn so many threads for request processing purposes, any thread that spends too much time processing the same request effectively decreases the web server’s overall request processing capacity.</p>
<p>Suppose there was no worker pool and the HTTP server had to handle all computation on its own. Suppose again that it takes 10 seconds to process a request for <code class="code docutils literal notranslate"><span class="pre">x</span></code>. Let’s say that the HTTP server is allowed to spawn up to 50 request processing threads. If 50 users send a requests for <code class="code docutils literal notranslate"><span class="pre">x</span></code> all within 10 seconds of one another, the HTTP server will become completely unable to process any other requests until at least one of the threads becomes available again. In the worst case, in which all 50 users sent the request at the same time, it could take 10 seconds before the HTTP server is able to process any other requests!</p>
<p>Since the worker pool handles all time-intensive computation, no HTTP server thread is blocked for more than a few milliseconds. It would take a massive number of requests to block the web server even for one second.</p>
<div class="section" id="http-server">
<h2>HTTP Server<a class="headerlink" href="#http-server" title="Permalink to this headline">¶</a></h2>
<p>Fractal’s HTTP server is implemented using the Flask web framework for Python.</p>
</div>
<div class="section" id="redis-store">
<h2>Redis store<a class="headerlink" href="#redis-store" title="Permalink to this headline">¶</a></h2>
<p>As stated above, the Redis store is the primary communication channel between the HTTP server and the Worker pool. Generally, it stores state that needs to be shared across multiple HTTP server or worker processes. We can approximately classify all pieces of of state in the Redis store as either server state or task state.</p>
<div class="section" id="server-state">
<h3>Server state<a class="headerlink" href="#server-state" title="Permalink to this headline">¶</a></h3>
<p>During deployment, Heroku may run Fractal’s HTTP server in multiple concurrent processes. This allows Heroku to load-balance requests across all available server processes, improving performance at scale.</p>
<p>The fact that each process has its own memory makes it challenging to share information between HTTP server instances; we can’t simply synchronize access to a global variable because each process will have an independent copy of the variable. Instead, we synchronize access to a global Redis store.</p>
<p>For example, there is a key in our Redis store that determines whether or not web server processes are allowed to accept incoming requests. All processes running the HTTP server read the same key from the Redis instance as though it were a global variable.</p>
</div>
<div class="section" id="task-state">
<h3>Task state<a class="headerlink" href="#task-state" title="Permalink to this headline">¶</a></h3>
<p>Tasks appear in the Redis store for two reasons. They first appear in the Redis store when they are added to the task queue by the web server. They are moved to a different part of the Redis store when they are picked up by a worker. They remain here until they have been processed completely.</p>
</div>
</div>
<div class="section" id="worker-pool">
<h2>Worker pool<a class="headerlink" href="#worker-pool" title="Permalink to this headline">¶</a></h2>
<p>The Celery package for Python provides us with a platform upon which to implement our worker pool’s functionality. Celery defines the following roles:</p>
<ul class="simple">
<li><p>Clients add tasks to task queues and may wait for results to become available,</p></li>
<li><p>Brokers implement task queues,</p></li>
<li><p>Backends store the results of processed tasks, and</p></li>
<li><p>Workers process tasks pending in task queues.</p></li>
</ul>
<p>In Fractal’s case, our HTTP server is a Celery client. It enqueues long-running functions in our task queue to avoid blocking its own threads. Our Redis store acts both as a task broker and a result backend, meaning that it stores not only metadata about tasks that are yet to be processed, but also the results of tasks that have already been handled by workers.</p>
<p>All that’s left is the Celery worker. It is launched with the <code class="code docutils literal notranslate"><span class="pre">celery</span> <span class="pre">worker</span></code> command.</p>
<p>An interesting thing to note is that we’ve decided to attach a worker pool to our deployment not because our web server is responsible for large amounts of intense computation, but rather because it spends a lot of time polling external services. In other words, our long-running functions spend most of their time sleeping and making simple network requests.</p>
<div class="section" id="scaling-the-worker-pool">
<h3>Scaling the worker pool<a class="headerlink" href="#scaling-the-worker-pool" title="Permalink to this headline">¶</a></h3>
<p>When deployed, we use a Heroku add-on service called HireFire to automatically scale our Celery workers. Based on the number of pending tasks in the task queue and the number of Celery “dynos” running on our Heroku app, HireFire may decide to scale that number up or down.</p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Fractal</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Web server architecture</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#http-server">HTTP Server</a></li>
<li class="toctree-l2"><a class="reference internal" href="#redis-store">Redis store</a></li>
<li class="toctree-l2"><a class="reference internal" href="#worker-pool">Worker pool</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="responsibilities.html">Web server responsibilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="services.html">Other services</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to Fractal’s documentation!</a></li>
      <li>Next: <a href="responsibilities.html" title="next chapter">Web server responsibilities</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Fractal.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/architecture.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>