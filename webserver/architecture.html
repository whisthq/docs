
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Webserver Architecture &#8212; Fractal Webserver  documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Webserver Responsibilities" href="responsibilities.html" />
    <link rel="prev" title="Welcome to the Fractal Webserver internal documentation!" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="webserver-architecture">
<h1>Webserver Architecture<a class="headerlink" href="#webserver-architecture" title="Permalink to this headline">¶</a></h1>
<p>When deployed, the so-called “Fractal Webserver” is not so much a web server as it is a group of three closely-related
services:</p>
<ul class="simple">
<li><p>The HTTP server itself</p></li>
<li><p>An asynchronous task queue</p></li>
<li><p>A worker pool</p></li>
</ul>
<p>Only the HTTP server is accessible to the public. The HTTP server and the worker pool, using the asynchronous task queue as
their primary communication channel, work together to process all incoming requests. Any time the Fractal Webserver receives
a request that would take more than a few milliseconds to process, it adds the processing of that request to the asynchronous
task queue and immediately returns a unique ID identifying the entry in the queue to the caller (usually the Fractal Desktop
Applications). The caller can use this unique ID to poll for the tasks’ status while it waits in the queue to be picked up
by a worker and while the task is being processed. When the tasks’ processing is complete, the caller can use the unique ID
to retrieve the result.</p>
<p>We have chosen to pair a worker pool with our HTTP server in this way to increase the worst-case rate at which our webserver
can process requests. Since the HTTP server processes each request in its own thread and it is only practical to spawn so
many threads for request processing purposes, any thread that spends too much time processing the same request effectively
decreases the HTTP server’s overall request processing capacity.</p>
<p>Suppose there was no worker pool and the HTTP server had to handle all computation on its own. Suppose again that it takes
10 seconds to process a request for <code class="code docutils literal notranslate"><span class="pre">x</span></code>. Let’s say that the HTTP server is allowed to spawn up to 50 request processing
threads. If 50 users send a requests for <code class="code docutils literal notranslate"><span class="pre">x</span></code> all within 10 seconds of one another, the HTTP server will become
completely unable to process any other requests until at least one of the threads becomes available again. In the worst case,
in which all 50 users sent the request at the same time, it could take 10 seconds before the HTTP server is able to process
any other requests!</p>
<p>Since the worker pool handles all time-intensive computation, no HTTP server thread is blocked for more than a few
milliseconds. It would take a massive number of requests to block the webserver even for one second.</p>
<div class="section" id="http-server">
<h2>HTTP Server<a class="headerlink" href="#http-server" title="Permalink to this headline">¶</a></h2>
<p>Fractal’s HTTP server is implemented using the Flask web framework for Python.</p>
</div>
<div class="section" id="redis-store">
<h2>Redis Store<a class="headerlink" href="#redis-store" title="Permalink to this headline">¶</a></h2>
<p>As stated above, the Redis store is the primary communication channel between the HTTP server and the Worker pool. Generally,
it stores state that needs to be shared across multiple HTTP server or worker processes. We can approximately classify all
pieces of state in the Redis store as either server state or task state, where a “task” is a function that the HTTP server
wants the worker pool to compute asynchronously on some input.</p>
<div class="section" id="server-state">
<h3>Server State<a class="headerlink" href="#server-state" title="Permalink to this headline">¶</a></h3>
<p>During deployment, Heroku may run Fractal’s HTTP server in multiple concurrent processes. This allows Heroku to load-balance
requests across all available server processes, improving performance at scale.</p>
<p>The fact that each process has its own memory makes it challenging to share information between HTTP server instances; we
can’t simply synchronize access to a global variable because each process will have an independent copy of the variable.
Instead, we synchronize access to a global Redis store.</p>
<p>For example, there is a key in our Redis store that determines whether or not HTTP server processes are allowed to accept
incoming requests. All processes running the HTTP server read the same key from the Redis instance as though it were a global
variable.</p>
</div>
<div class="section" id="task-state">
<h3>Task State<a class="headerlink" href="#task-state" title="Permalink to this headline">¶</a></h3>
<p>As mentioned above, a task is a function that the HTTP server wants the worker pool to compute asynchronously on some input.
They appear in the Redis store for two reasons. First, they appear as pairs of code and input when the HTTP server adds them
to the queue. They are moved to a different data structure in the Redis store when they are picked up by a worker. They
remain here until they have been processed completely.</p>
</div>
</div>
<div class="section" id="worker-pool">
<h2>Worker Pool<a class="headerlink" href="#worker-pool" title="Permalink to this headline">¶</a></h2>
<p>The Celery package for Python provides us with a platform upon which to implement our worker pool’s functionality. Celery
defines the following roles:</p>
<ul class="simple">
<li><p>Clients add tasks to task queues and may wait for results to become available</p></li>
<li><p>Brokers implement task queues</p></li>
<li><p>Backends store the results of processed tasks</p></li>
<li><p>Workers process tasks pending in task queues</p></li>
</ul>
<p>In Fractal’s case, our HTTP server is a Celery client. It enqueues long-running functions in our task queue to avoid blocking
its own threads. Our Redis store acts both as a task broker and a result backend, meaning that it stores not only metadata
about tasks that are yet to be processed, but also the results of tasks that have already been handled by workers. All that’s
left is the Celery worker. It is launched with the <code class="code docutils literal notranslate"><span class="pre">celery</span> <span class="pre">worker</span></code> command.</p>
<p>An interesting thing to note is that we’ve decided to attach a worker pool to our deployment not because our webserver is
responsible for large amounts of intense computation, but rather because it spends a lot of time polling external services.
In other words, our long-running functions spend most of their time sleeping and making simple network requests.</p>
<div class="section" id="scaling-the-worker-pool">
<h3>Scaling the Worker Pool<a class="headerlink" href="#scaling-the-worker-pool" title="Permalink to this headline">¶</a></h3>
<p>When deployed, we use a Heroku add-on service called HireFire to automatically scale our Celery workers. Based on the number
of pending tasks in the task queue and the number of Celery “dynos” running on our Heroku app, HireFire may decide to scale
that number up or down to match compute needs.</p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Fractal Webserver</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Webserver Architecture</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#http-server">HTTP Server</a></li>
<li class="toctree-l2"><a class="reference internal" href="#redis-store">Redis Store</a></li>
<li class="toctree-l2"><a class="reference internal" href="#worker-pool">Worker Pool</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="responsibilities.html">Webserver Responsibilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="services.html">Other Services</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to the Fractal Webserver internal documentation!</a></li>
      <li>Next: <a href="responsibilities.html" title="next chapter">Webserver Responsibilities</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Fractal Computers, Inc..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/architecture.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>