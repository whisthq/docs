<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Whist Protocol: Debugging Tools</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Whist Protocol
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_whist_debug_README.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Debugging Tools </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This folder contains a variety of tools we use to debug and analyze the Whist <code>/protocol</code> project.</p>
<h1><a class="anchor" id="autotoc_md141"></a>
Debug Console</h1>
<h2><a class="anchor" id="autotoc_md142"></a>
Overview</h2>
<p>When enabled, the <code>Debug Console</code> provides a telnet style console on port 9090 at client side, allows you to send commands to the client while it is running. You can change parameters of the client interactively/dynamically (e.g. change <code>bitrate</code> <code>audio_fec_ratio</code> <code>video_fec_ratio</code>), or let the program run some commands for you (e.g. get report from <code>protocol_analyzer</code>).</p>
<p>You can find images illustrating this process inside this <a href="https://github.com/whisthq/whist/pull/5352">PR</a>.</p>
<h2><a class="anchor" id="autotoc_md143"></a>
How to enable</h2>
<p>Debug Console can only be enabled with a <code>DEBUG</code> build.</p>
<p>To enable the debug console, add <code>--debug-console PORT</code> to the options of client, for example:</p>
<p>If without debug console, the command is:</p>
<div class="fragment"><div class="line">./wclient 54.219.45.195 -p32262:30420.32263:35760.32273:4473 -k 1ef9aec50197a20aa35b68b85fb7ace0</div>
</div><!-- fragment --><p>Then the following command will run the client with debug console enable on port 9090:</p>
<div class="fragment"><div class="line">./wclient 54.219.45.195 -p32262:30420.32263:35760.32273:4473 -k 1ef9aec50197a20aa35b68b85fb7ace0 --debug-console 9090</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md144"></a>
How to access</h2>
<p>the easiest way to access debug console is to use the tool <code>netcat</code>:</p>
<div class="fragment"><div class="line">nc 127.0.0.1 9090 -u</div>
</div><!-- fragment --><p>Then you get a telnet style console. You can run commands (inside the console) and get outputs, in a way similar to a shell (e.g. <code>bash</code>).</p>
<p>the <code>rlwrap</code> tool can make your use of <code>netcat</code> easier, e.g. you can use the arrows to move cursor and recall previous command, when used with rlwrap, the full commands is:</p>
<div class="fragment"><div class="line">rlwrap nc 127.0.0.1 9090 -u</div>
</div><!-- fragment --><p>(you can get both <code>netcat</code> and <code>rlwrap</code> easily from <code>apt</code> or <code>brew</code>)</p>
<h2><a class="anchor" id="autotoc_md145"></a>
Support Commands</h2>
<h3><a class="anchor" id="autotoc_md146"></a>
&lt;tt&gt;report_XXX&lt;/tt&gt;</h3>
<p>use <code>report_video</code> or <code>report_audio</code> to get a report of the last <code>report_num</code> (default:2000) of records of video or audio.</p>
<p><code>report_video_moreformat</code> or <code>report_audio_moreformat</code> are similar, increase the use of format string at the cost of a longer output.</p>
<p>examples:</p>
<div class="fragment"><div class="line">report_video  video1.txt                    #get a report of video, save to video1.txt</div>
<div class="line">report_audio  /home/yancey/audio1.txt       #get a report of audio, save to /home/yancey/audio1.txt</div>
<div class="line">report_video_moreformat  video2.txt         #get a report of video, with more format attempt</div>
<div class="line">report_audio_moreformat  audio2.txt.cpp     #get a report of audio, save the file as cpp, so that you can cheat your editor to highlight it</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md147"></a>
&lt;tt&gt;set&lt;/tt&gt;</h3>
<p>Set allows you to change parameters inside the client dynamically. Support parameters:</p>
<ul>
<li><code>video_fec_ratio</code>, change the video fec ratio</li>
<li><code>audio_fec_ratio</code>, change the audio fec ratio</li>
<li><code>bitrate</code>, force the bitrate outputted by bitrate algorithm</li>
<li><code>burst_bitrate</code>, force the burst bitrate</li>
<li><code>no_minimize</code>, disable the MESSAGE_STOP_STREAMING sent by client when there is a window minimize, which might be annoying for debugging (e.g. when switching to other window and look at logs)</li>
<li><code>verbose_log</code>, toggle the verbose_log flag, enable more logs inside the client.</li>
<li><code>report_num</code>, change the number of records/frames included inside a report, default: 2000</li>
<li><code>skip_last</code>, skip the last n frames recorded by the analyzer, default:60. (the last few records might not have not arrived yet, including them will make metrics inaccurate)</li>
</ul>
<p>Examples:</p>
<div class="fragment"><div class="line">set video_fec_ratio 0.15             #set video fec ratio to 0.15</div>
<div class="line">set verbose_log 1                    #enable verbose log</div>
<div class="line">set bitrate 2000000                  #force bitrate to 2Mbps</div>
<div class="line">set report_num 5000                  #include 5000 records in following reports</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md148"></a>
&lt;tt&gt;info&lt;/tt&gt;</h3>
<p>Take a peek of the values of parameters supported by set</p>
<h3><a class="anchor" id="autotoc_md149"></a>
&lt;tt&gt;insert_atexit_handler&lt;/tt&gt; or &lt;tt&gt;insert&lt;/tt&gt;</h3>
<p>Insert a atexit handler that turns exit() to abort, so that we can get the stack calling exit(). It's helpful for debugging problems, when you don't know where in the code called exit(), especially the exit() is called in some lib.</p>
<h3><a class="anchor" id="autotoc_md150"></a>
&lt;tt&gt;plot_xxx&lt;/tt&gt;</h3>
<p>Use <code>plot_start</code> to start or restart (the sampling of) plotting.</p>
<p>Use <code>plot_export &lt;filename&gt;</code> to export the plot data to a file, which can be future turned into plot graphs by the <code>plotter.py</code>. Examples:</p>
<div class="fragment"><div class="line">#inside debug console</div>
<div class="line">plot_export /Users/yancey/demo.json</div>
<div class="line"> </div>
<div class="line">#inside shell</div>
<div class="line">./plotter.py ~/demo.json</div>
</div><!-- fragment --><p>Use <code>plot_stop</code> to stop (the sampling) of plotting, e.g avoid waste of CPU and memory used on sampling.</p>
<h1><a class="anchor" id="autotoc_md151"></a>
Protocol Analyzer</h1>
<h2><a class="anchor" id="autotoc_md152"></a>
Overview</h2>
<p>This is a protocol analyzer in the side-way style, that you can talk to interactively via the debug console. Allows you to analyze the protocol dynamically, get advanced metrics.</p>
<p>Features/Advantages:</p>
<ul>
<li>It only gives output if you ask to, instead of spamming the log. As a result you can put as many infos as you like.</li>
<li>It tracks the life of frames/segments, organize info in a compact structured way. Reduce eye parsing and brain processing.</li>
<li>Centralized way to put meta infos, allows advanced metric to be implemented easily.</li>
<li>It hooks into the protocol to track the protocol's running, instead of inserting attributes into the data structures of protocol. Almost doesn't increase the complexity of code of protocol</li>
</ul>
<p>Disadvantages:</p>
<ul>
<li>when you make serious changes to the protocol, you need to update the protocol analyzer to track it correctly, increases maintain burden of codebase. But (1) this usually won't happen unless something essential is changed in protocol (2) when it happens it should be easy to update the analyzer</li>
</ul>
<h2><a class="anchor" id="autotoc_md153"></a>
How to run</h2>
<p>When debug console is enabled, the protocol analyzer is automatically enabled. You don't need to explicitly start it, all you need to do is talk to it via <code>debug_console</code>. To get report from it, or change some parameters (e.g <code>report_num</code>, <code>skip_last</code>)</p>
<h2><a class="anchor" id="autotoc_md154"></a>
Report format</h2>
<p>The report of protocol analyzer consists two sections: (1) high level information/statistics (2) a breakdown of all frames inside the report</p>
<h3><a class="anchor" id="autotoc_md155"></a>
High-level information/statistic</h3>
<p>This section is a list of information/statistic, consist of:</p>
<ul>
<li><code>type</code>, whether the report is for audio or video. Possible values: <code>VIDEO</code> or <code>AUDIO</code></li>
<li><code>frame_count</code>, number of frames includes in the report</li>
<li><code>frame_seen_count</code>, number of frames that are seen, i.e, we received at least one segment of those frames.</li>
<li><code>first_seen_to_ready_time</code>, the average time that frames become ready to render from first seen. Unit: ms</li>
<li><code>first_seen_to_decode_time</code>, the average time that frames are fed to decode from first seen. Unit: ms</li>
<li><code>recover_by_nack</code>, the percentage of frames recovered by nack. "Recovered by nack" means, when the frame becomes ready, at least one retransmission of packet arrives</li>
<li><code>recover_by_fec</code>, the percentage of frames recovered by fec.</li>
<li><code>recover_by_fec_after_nack</code>, the percentage of frames that is recovered by fec followed after nack. Or you think those frames are recovered by both fec and nack.</li>
<li><code>false_drop</code>, the percentage of frames that becomes ready but never feed into decoder</li>
<li><code>recoverable_drop</code>, the percentage of frames that only lost a small proportion (&lt;10%), should be recovered easily but actually never become ready.</li>
<li><code>not_seen</code>, the percentage of frames that we never saw a single segment for.</li>
<li><code>not_ready</code>, the percentage of frames that never become ready.</li>
<li><code>not_decode</code>, the percentage of frames that was never feed into decoder</li>
<li><code>frame_skip_times</code>, the times of frames skips happened</li>
<li><code>num_frames_skiped</code>, the number of total frame skipped</li>
<li><code>ringbuffer_reset_times</code>, the times of ringbuffer reset happened</li>
<li><code>estimated_network_loss</code>, the estimated network packet loss. (only exist in <code>VIDEO</code> report)</li>
</ul>
<p>All time are the relative time since client start. This also applies to the sections below, in the whole report.</p>
<h3><a class="anchor" id="autotoc_md156"></a>
Breakdown of frames</h3>
<p>This section is a list of frame infos, each one consist of:</p>
<p>Main Attributes(always showing):</p>
<ul>
<li><code>id</code>, id of the frame</li>
<li><code>type</code>, type of frame. Possible values: <code>VIDEO</code> or <code>AUDIO</code></li>
<li><code>num</code>, the number of all packets inside the frame, including fec packets.</li>
<li><code>fec</code>, the number of fec packets inside the frame.</li>
<li><code>frame_type</code>, the type of frame, e.g. intra frame or normal frame. (Only for <code>Video</code>)</li>
<li><code>first_seen</code>, the time we first seen the frame, i.e. the first segment of the frame arrives</li>
<li><code>ready_time</code>, the time when the frame becomes ready to render, correspond to the <code><a class="el" href="ringbuffer_8c.html#a22897ddd74ba2d11192502d98a4c7227" title="Indicate that the frame with ID id is currently rendering, and free the frame buffer for the previous...">is_ready_to_render()</a></code> insider <code><a class="el" href="ringbuffer_8c.html">ringbuffer.c</a></code></li>
<li><code>pending_time</code>, the time when the frame becomes pending, i.e. in a state that is waiting to be taken by the decoder thread</li>
<li><code>decode_time</code>, the time when the frame is fed into the decoder.</li>
<li><code>segments</code>, a break down of segments info</li>
</ul>
<p>(In addition to the possible values, the value can be <code>-1</code> or <code>null</code>, indicate there is no value available)</p>
<p>Other attributes(onlys shows when there are something interesting happens):</p>
<ul>
<li><code>nack_used</code>, when this shows, it means nack is used for recovering this frame</li>
<li><code>fec_used</code>, when this shows, it means fec is used fro recovering this frame</li>
<li><code>skip_to</code>, when this shows, it means there is a frame skip from the current frame to the frame <code>skip_to</code> points to</li>
<li><code>reset_ringbuffer_to</code>, when this shows, it means there is a ringbuffer reset from the current frame to the frame <code>reset_ringbuffer_to</code> points to</li>
<li><code>reset_ringbuffer_from</code>, when this shows, it means there is a ringbuffer reset from the frame <code>reset_ringbuffer_from</code> points to, to the current frame. (kind of redundant with above)</li>
<li><code>overwrite</code>, when this shows, it means when the current frame becomes "current rendering" inside ringbuffer, it overwrites a frame that never becomes pending</li>
<li><code>queue full</code>, when this shows, it means when the current frame tries to become pending, it triggers an "Audio queue full". (Only for audio)</li>
</ul>
<h4><a class="anchor" id="autotoc_md157"></a>
Breakdown of segments</h4>
<p>The breakdown of segments is a list of items. Each items correspond of a segment of the frame, contains:</p>
<ul>
<li><code>idx</code>, the index of segment. this <code>idx</code> label is omitted by default output</li>
<li>a list contains 3 sections:<ul>
<li><code>arrival</code>, a list of all times of packets which arrive without an <code>is_a_nack</code> flag, i.e. the non-retransmit packets. The label is omitted by default output.</li>
<li><code>retrans_arrival</code>, a list all times of packets which arrive with an <code>is_a_nack</code> flag, i.e. the retransmitted packets. The label is shown as <code>retr</code> by default output, for short.</li>
<li><code>nack_sent</code> , a list of all times of an NACK is sent for this segment. The label is shown as <code>nack</code> by default output, for short.</li>
</ul>
</li>
</ul>
<p>Note about the terminology: A <code>segment</code> is a segment of <code>frame</code>, a <code>segment</code> is sent via a <code>packet</code>. There might be multiple <code>packets</code> contains the same <code>segment</code>.</p>
<p>An example that helps understand, with default format:</p>
<div class="fragment"><div class="line">segments=[</div>
<div class="line">{0[4542.4,4543.0]},</div>
<div class="line">{1[4545.0]},</div>
<div class="line">{2[4545.1; retr:4630.0; nack:4545.0]},</div>
<div class="line">{3[retr:4640.3; nack:4560.0]},</div>
<div class="line">{4[retr:4680.0; nack:4561.0, 4610.0]},</div>
<div class="line">{5[4545.2]}]</div>
</div><!-- fragment --><p>or with the <code>moreformat</code> format:</p>
<div class="fragment"><div class="line">segments=[</div>
<div class="line">{idx=0,[arrival:4542.4,4543.0]},</div>
<div class="line">{idx=1,[arrival:4545.0]},</div>
<div class="line">{idx=2,[arrival:4546.1;retrans_arrival:4630.0; nack_sent:4545.0]},</div>
<div class="line">{idx=3,[retrans_arrival:4640.3; nack_sent:4560.0]},</div>
<div class="line">{idx=4,[retrans_arrival:4680.0; nack_send:4561.0, 4610.0]},</div>
<div class="line">{idx=5,[arrivale:4545.2]}]</div>
</div><!-- fragment --><p>(this is an artificial example for help understanding, it should be rare to see such segments in real use )</p>
<p>(the outputs are in one line in the real output, instead of multiple lines, to reduce page space. an editor plug-in such as <code>rainbow_parentheses</code>, significantly increase the readability, it's very suggested to install one)</p>
<p>In the example, the frame consist of 6 segments:</p>
<ol type="1">
<li>The 0th segment arrives twice without nack, there might be a network duplication.</li>
<li>the 1st segment arrives as normal</li>
<li>for the 2nd segment, the non-retransmit packet successfully arrives, but there is still an NACK sent, and we got the retransmitted segment</li>
<li>for the 3rd segment, the non-retransmit packet got lost, and NACK was sent, we got the retransmitted segment.</li>
<li>for the 4th segment, the non-retransmit packet got lost, and NACK was sent, the retransmit segment got lost, we sent and NACK again. And finally got the segment.</li>
<li>the 5th segment arrives as normal.</li>
</ol>
<h2><a class="anchor" id="autotoc_md158"></a>
Implementation</h2>
<p>This section talks about the implementation of protocol analyzer, hopefully you can get an idea on how to extend it.</p>
<p>The protocol analyzer mainly consist of:</p>
<ol type="1">
<li>data structures, that store the recorded info</li>
<li>hooks, that hook into the protocol to record info</li>
<li>statistics generator, for the high-level info/stat in report</li>
<li>pretty printer for the frame breakdown in report</li>
</ol>
<h3><a class="anchor" id="autotoc_md159"></a>
Data structures</h3>
<p>Below are the data structures used for protocol analyzer.</p>
<div class="fragment"><div class="line">//info at segment level</div>
<div class="line">Struct SegmentLevelInfo</div>
<div class="line">{</div>
<div class="line">... //attributes</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">//info at frame level</div>
<div class="line">struct FrameLevelInfo {</div>
<div class="line">map&lt;int, SegmentLevelInfo&gt; segments;</div>
<div class="line">... //attributes</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">//a map from id to frame</div>
<div class="line">typedef map&lt;int, FrameLevelInfo&gt; FrameMap;</div>
<div class="line"> </div>
<div class="line">// type level info.  By &quot;type&quot; I mean VIDEO or AUDIO</div>
<div class="line">struct TypeLevelInfo {</div>
<div class="line">    FrameMap frames;</div>
<div class="line">    ... //attributes</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">//the protocol analyzer class</div>
<div class="line">struct ProtocolAnalyzer {</div>
<div class="line">    map&lt;int, TypeLevelInfo&gt; type_level_infos;   //a map from type to type level info.</div>
<div class="line">}</div>
</div><!-- fragment --><p>If you want to record new info, you will need to put it as an attribute of the data structures.</p>
<h3><a class="anchor" id="autotoc_md160"></a>
Hooks</h3>
<p>Hooks are the public functions with name <code>whist_analyzer_record_XXXXX()</code>, they hook into the protocol and save info into the data structure, for example:</p>
<div class="fragment"><div class="line">// record info related to the arrival of a segment</div>
<div class="line">void whist_analyzer_record_segment(WhistSegment *packet)</div>
<div class="line">{</div>
<div class="line">  FUNC_WRAPPER(record_segment, packet);</div>
<div class="line">}</div>
</div><!-- fragment --><p>It's a wrapper of the corresponding method of ProtocolAnalyzer class:</p>
<div class="fragment"><div class="line">void ProtocolAnalyzer::record_segment()</div>
<div class="line">{</div>
<div class="line">//real implementation is here</div>
<div class="line">}</div>
</div><!-- fragment --><p>If you want to record new info, you might need to implement new hooks.</p>
<h3><a class="anchor" id="autotoc_md161"></a>
Statistics generator</h3>
<p>The Statistics generator is just the function:</p>
<div class="fragment"><div class="line">string ProtocolAnalyzer::get_stat(ï¼‰</div>
<div class="line">{</div>
<div class="line">...</div>
<div class="line">}</div>
</div><!-- fragment --><p>If you want to implement new metric/stat, add code to this function</p>
<h3><a class="anchor" id="autotoc_md162"></a>
Pretty printer for frame breakdown</h3>
<p>The pretty printer for frame breakdown is just the function:</p>
<div class="fragment"><div class="line">string FrameLevelInfo::to_string()</div>
<div class="line">{</div>
<div class="line">...</div>
<div class="line">}</div>
</div><!-- fragment --><p>If you want new attributes of frames to be printed out, add code to this function.</p>
<h1><a class="anchor" id="autotoc_md163"></a>
Plotter</h1>
<h2><a class="anchor" id="autotoc_md164"></a>
Overiew</h2>
<p>the Plotter consist of the C++ APIs part (<code><a class="el" href="plotter_8h.html" title="Copyright (c) 2021-2022 Whist Technologies, Inc.">plotter.h</a></code> and <code>plotter.cpp</code>) and the python helper <code>plotter.py</code> part.</p>
<h3><a class="anchor" id="autotoc_md165"></a>
C++ API part</h3>
<h4><a class="anchor" id="autotoc_md166"></a>
Controlling APIs:</h4>
<div class="fragment"><div class="line">void whist_plotter_init(void);  // init the plotter</div>
</div><!-- fragment --><p>This is typically called on client and server startup. But you can also call it inside unit-test if needed.</p>
<div class="fragment"><div class="line">void whist_plotter_start_sampling(void);  // start sampling,</div>
<div class="line">void whist_plotter_stop_sampling(void);   // stop sampling</div>
</div><!-- fragment --><p>They can be called at any place.</p>
<h4><a class="anchor" id="autotoc_md167"></a>
Sampling API:</h4>
<div class="fragment"><div class="line">void whist_plotter_insert_sample(const char* label, double x, double y);</div>
</div><!-- fragment --><p>This function can be called at any place. The first parameter <code>label</code> is the label of data point <code>{x,y}</code>, data point with same label are considered to belong to a same data collection and has the same color in plotting. The <code>x</code> and <code>y</code>, are self-explained values to be plotted.</p>
<h3><a class="anchor" id="autotoc_md168"></a>
Data Exporting API:</h3>
<div class="fragment"><div class="line">std::string whist_plotter_export();</div>
</div><!-- fragment --><p>This function exports the sampled values to a string of json, which can be turned into graphs by the <code>plotter.py</code>.</p>
<p>This function can be called at any place.</p>
<h3><a class="anchor" id="autotoc_md169"></a>
Python Helper Part</h3>
<p>The python helper is the <code>plotter.py</code>, which turns the exported data into graphs. Full options:</p>
<div class="fragment"><div class="line">Usage: plotter.py [options] filename1 [filename2 ...]</div>
<div class="line"> </div>
<div class="line">Options:</div>
<div class="line">  -h, --help            show this help message and exit</div>
<div class="line">  -s, --scatter         draw scatter instead of line</div>
<div class="line">  -d, --distribution    draw distribution of y, instead of the x-y plot</div>
<div class="line">  -f FILTER_PATTERN, --filter=FILTER_PATTERN</div>
<div class="line">                        regex expression to filter label names</div>
<div class="line">  -v, --inverse-match   when used together with -f, do inverse match</div>
<div class="line">  -r RANGE_X, --range=RANGE_X</div>
<div class="line">                        range of x, e.g. &quot;10.0~15.0&quot;</div>
<div class="line">  -w WEIGHT, --weight=WEIGHT</div>
<div class="line">                        weight of the line or point, default: 0.5</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md170"></a>
Introduce to the use of plotter</h2>
<h3><a class="anchor" id="autotoc_md171"></a>
Start and Stop sampling</h3>
<p>For client, you can start and stop sampling by talking to debug_console. See the <code>debug_console</code> section above.</p>
<p>For both client and server, you can enable auto start/stop sampling on program start/quit by <code>CLIENT_SIDE_PLOTTER_START_SAMPLING_BY_DEFAULT</code> or <code>SERVER_SIDE_PLOTTER_START_SAMPLING_BY_DEFAULT</code> macro. See the <code>debug_flag.h</code> file.</p>
<h3><a class="anchor" id="autotoc_md172"></a>
Practices for using the Sampling API</h3>
<p>To easily control the plotting of data, and to avoid wasting CPU and memory to sample the data you are not interested.</p>
<p>It's suggested to organize related datasets as a group, and enable/disable the group as needed.</p>
<p>This can be done in two ways:</p>
<ol type="1">
<li>use MACRO</li>
<li>use the dynamic value change mechanism of <code>debug_console</code>, AKA the <code>set</code> command.</li>
</ol>
<h4><a class="anchor" id="autotoc_md173"></a>
MACRO Method</h4>
<p>Define PLOT_AUDIO_ALGO inside <code><a class="el" href="debug__flags_8h.html">debug_flags.h</a></code>:</p>
<div class="fragment"><div class="line">#define PLOT_AUDIO_ALGO false                // audio algo</div>
</div><!-- fragment --><p>Guard the group of datasets with macro:</p>
<div class="fragment"><div class="line">if (PLOT_AUDIO_ALGO) {</div>
<div class="line">    double current_time = get_timestamp_sec();</div>
<div class="line">    whist_plotter_insert_sample(&quot;audio_device_queue&quot;, current_time, device_queue_len);</div>
<div class="line">    whist_plotter_insert_sample(&quot;audio_total_queue&quot;, current_time, total_queue_len);</div>
<div class="line">    whist_plotter_insert_sample(&quot;audio_scale_factor&quot;, current_time,</div>
<div class="line">                                adaptive_parameter_controller.get_scale_factor());</div>
<div class="line">}</div>
</div><!-- fragment --><p>Then you can enable/disable the group at compile time with MACRO.</p>
<h4><a class="anchor" id="autotoc_md174"></a>
dynamic Method</h4>
<p>If a group of data need to be looked very frequently, you might want to enable/disable the group without re-compile.</p>
<p>First, you define <code>plot_audio_algo</code> inside the <code><a class="el" href="structDebugConsoleOverrideValues.html">DebugConsoleOverrideValues</a> struct</code> of <code>debug_consol.h</code>. And make the relevant modification to <code>handle_set()</code> <code>handle_info()</code> to support that variable.</p>
<p>Guard the group with the <code>plot_audio_algo</code> variable:</p>
<div class="fragment"><div class="line">if (get_debug_console_override_values()-&gt;plot_audio_algo) {</div>
<div class="line">    double current_time = get_timestamp_sec();</div>
<div class="line">    whist_plotter_insert_sample(&quot;audio_device_queue&quot;, current_time, device_queue_len);</div>
<div class="line">    whist_plotter_insert_sample(&quot;audio_total_queue&quot;, current_time, total_queue_len);</div>
<div class="line">    whist_plotter_insert_sample(&quot;audio_scale_factor&quot;, current_time,</div>
<div class="line">                                adaptive_parameter_controller.get_scale_factor());</div>
<div class="line">}</div>
</div><!-- fragment --><p>Then you can enable/disable the group with:</p>
<div class="fragment"><div class="line">#inside debug console</div>
<div class="line">set plot_audio_algo 1           #to enable</div>
<div class="line">set plot_audio_algo 0           #to disable</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md175"></a>
Examples of using the &lt;tt&gt;plotter.py&lt;/tt&gt;</h3>
<h3><a class="anchor" id="autotoc_md176"></a>
Basic usage</h3>
<div class="fragment"><div class="line">./plotter.py ~/sdl_present_cpu_copy.json</div>
</div><!-- fragment --><p><img src="https://user-images.githubusercontent.com/4922024/176613266-80a41f03-69dc-4ec9-bac5-19143f66668e.png" alt="" width="400" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md177"></a>
Change style</h3>
<p>Sometimes the lines are too dense and hides each other, you can change style to scatter for a better view:</p>
<div class="fragment"><div class="line">./plotter.py ~/saved_plots/audio_algo_new_piece.json -s</div>
</div><!-- fragment --><p>default style vs scatter style:</p>
<p><img src="https://user-images.githubusercontent.com/4922024/176612467-b9561388-e27c-4c09-ba56-cce24fbc341d.png" alt="" width="400" class="inline"/> <img src="https://user-images.githubusercontent.com/4922024/176612641-ebed72cf-d2d4-48c7-906f-e8af6694e882.png" alt="" width="400" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md178"></a>
Use distribution graph</h3>
<p>Sometimes the plot is filled by spikes, looking at the distribution of y value might give you a better understanding of data:</p>
<div class="fragment"><div class="line">./plotter.py ~/socket_queue_len.json -d</div>
</div><!-- fragment --><p>default graph vs distribution graph:</p>
<p><img src="https://user-images.githubusercontent.com/4922024/176611074-6849c5bd-8af4-42a4-8c82-adce80dd5297.png" alt="" width="400" class="inline"/> <img src="https://user-images.githubusercontent.com/4922024/176613048-ad841793-2370-4500-ad71-bb2e6a196632.png" alt="" width="400" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md179"></a>
Change Weight</h3>
<p>You can also change the weight of line or scatter with the <code>-w</code> option:</p>
<div class="fragment"><div class="line">./plotter.py ~/udp_dedicated_thread.json -d -w 2</div>
</div><!-- fragment --><p>default weight vs changed weight:</p>
<p><img src="https://user-images.githubusercontent.com/4922024/176620204-c7575168-0ad5-413c-a278-86aa02c6cd63.png" alt="" width="400" class="inline"/> <img src="https://user-images.githubusercontent.com/4922024/176620131-9980ce33-aaf3-43da-b41f-0e1465222ec3.png" alt="" width="400" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md180"></a>
User Label filter</h3>
<p>Sometimes the exported data contains too many labels than you are interested, you can filter out the interested lablel with regular expression:</p>
<div class="fragment"><div class="line">./plotter.py ~/saved_plots/audio_algo_new.json -f &#39;.*(scale|device).*&#39;</div>
</div><!-- fragment --><p>without filter vs with filter:</p>
<p><img src="https://user-images.githubusercontent.com/4922024/176617848-6af9c004-2c1f-46c7-a13e-f5c0c3fe6049.png" alt="" width="400" class="inline"/> <img src="https://user-images.githubusercontent.com/4922024/176618049-d4702445-063b-4c58-beb7-cd9f94363d0f.png" alt="" width="400" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md181"></a>
Plot only specific range</h3>
<p>Sometimes the graph contains a super lage range of data. You can use the zoom function of the UI to zoom, but huge amount of data might make your UI very slow.</p>
<p>So you might want to pre-specify a range of x data to plot, with the <code>-r</code> option:</p>
<div class="fragment"><div class="line">./plotter.py ~/saved_plots/audio_algo_new.json -r 35~60</div>
</div><!-- fragment --><p>without range vs with range:</p>
<p><img src="https://user-images.githubusercontent.com/4922024/176618908-bab9bc36-3727-4368-89a0-873c09ee6d67.png" alt="" width="400" class="inline"/> <img src="https://user-images.githubusercontent.com/4922024/176619182-f9e75493-db2d-4cec-acfd-fd6d584ce01f.png" alt="" width="400" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md182"></a>
Compare two plots</h3>
<p>For easier comparsion, you can specific multiple files to <code>./plotter</code>, and compare the graphs on the same picture:</p>
<div class="fragment"><div class="line">./plotter.py ~/my_pr.json ~/dev.json</div>
</div><!-- fragment --><p><img src="https://user-images.githubusercontent.com/4922024/176622283-2109e8da-c432-41df-a4a1-ab4671a18762.png" alt="" width="400" class="inline"/></p>
<p>Note that when you specific more than one input files, the labels are auto prefixed by the file name. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
