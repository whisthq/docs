<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fractal Protocol: Fractal Protocol</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Fractal Protocol
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Fractal Protocol </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> This repository contains the source code for the Fractal Protocol, which is a low-latency interactive streaming technology that streams audio/video/inputs between an OS-like device, whether it is a virtual machine, a container or a regular computer, and a client computer or mobile device.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Supported Platforms</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
Server</h2>
<p>This folder builds a server to stream via Fractal. It supports Windows and Linux Ubuntu. See below for basic build instructions, and the folder's README for build and development details.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Desktop</h2>
<p>This folder builds a client to receive a server stream via Fractal. It supports Windows, MacOS and Linux Ubuntu. See below for basic build instructions, and the folder's README for build and development details.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Android</h2>
<p>This folder builds a client to receive a server stream via Fractal on Android-based devices, including Chromebooks. See the folder's README for build and development details.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
iOS</h2>
<p>TBD</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Web</h2>
<p>TBD</p>
<h1><a class="anchor" id="autotoc_md7"></a>
High-Level Overview</h1>
<p>In order to give the user their low-latency high-FPS experience, the protocol executes the following processes in order from top-to-bottom:</p>
<ul>
<li><code>create_capture_device</code> from either <code>./fractal/video/dxgicapture.c</code> or <code>./fractal/video/x11capture.c</code> is called, the former is for Windows and the latter is for Linux. Then, <code>capture_screen</code> is called in <code>./server/main.c</code> to capture the screen.</li>
<li><code>encoder_t</code> from <code><a class="el" href="videoencode_8c.html" title="This file contains the code to create and destroy Encoders and use.">videoencode.c</a></code> will be used to encode the screenshot using h264, if needed. If Nvidia Capture SDK is being used (<code>USING_GPU_CAPTURE == true</code> and on linux), then the image will already be encoded upon capture, and this is not necessary.</li>
<li>A <code>Frame*</code> is created and the members of the <code><a class="el" href="structFrame.html">Frame</a></code> struct is filled in, see <code>./server/main.c</code> for the code and <code>./fractal/core/fractal.h</code> for the <code><a class="el" href="structFrame.html">Frame</a></code> struct.</li>
<li><code>broadcast_udp_packet</code> from <code>./server/network.c</code>is called with the <code>Frame*</code> passed in. This will break-up the <code>Frame*</code> into hundreds of individual network packets.</li>
<li>On the client, these packets are received in <code>./client/main.c</code> and passed into <code>receive_video</code> in <code>./client/video.c</code>.</li>
<li><code>receive_video</code> will receive video packets and will save them in a buffer (packet 17 will be stored at <code>buffer + PACKET_SIZE*(17-1)</code>, so that the packets go into their correct slot until the entire <code>Frame*</code> is recreated). <code><a class="el" href="video_8c.html" title="This file contains all code that interacts directly with receiving and.">video.c</a></code> keeps track of the ID of the most recently rendered frame, ie ID 247. Once all of the packets of ID 248 are received, it will take the pointer to the beginning of the buffer and then render it. Each packet will contain the number of packets for the <code>Frame*</code>, so once one is received, the client will know when all of them have been received.</li>
<li>Once a <code>Frame*</code> has been accumulated, <code>render_screen</code> in <code>./server/video.c</code> will trigger, and <code>video_decoder_decode</code> from <code>./fractal/video/videodecode.c</code> will be called. Any cursor image will be rendered on-top, along with <code>sws_scale</code>'ing if the frame is not the same resolution as the client. Peruse <code>render_screen</code> for further details.</li>
<li>Finally, <code>SDL_RenderPresent</code> will be called, rendering the <a class="el" href="structFrame.html">Frame</a>.</li>
<li>If no packet from the expected ID is received within a couple hundred milliseconds, or if a subset of packets have been received and it's been a couple hundred milliseconds since the last seen packet, then the <code>./client/video.c</code>protocol will send a <code><a class="el" href="video_8c.html#a206c41ca7dce6c36a9000ff2e21038c5">nack()</a></code> to the server in order to get a copy of the presumably dropped or missed packet. The server keeps the last couple <code>Frame*</code>'s in a buffer in order to respond to <code><a class="el" href="video_8c.html#a206c41ca7dce6c36a9000ff2e21038c5">nack()</a></code>'s.</li>
</ul>
<p>The same process is used for audio capture, encoding, decoding, and playing. See <code>send_audio</code> of <code>./server/main.c</code>, <code>./fractal/audio/audio{capture,encode,decode}.c</code>, and <code>receive_audio</code> of <code>./client/audio.c</code></p>
<p>Throughout the life of the protocol, various messages will be send to and from the client and server. For example, if the client and server are of different resolution, the image will appear stretched, so to fix this the client will send a message to server to ask the server to change resolutions to match the client.</p>
<ul>
<li>To send a message from client to server, call <code>send_fmsg</code>. See <code>./client/main.c</code> for usage.</li>
<li>To send a message from server to client, create a <code><a class="el" href="structFractalServerMessage.html">FractalServerMessage</a></code> and call <code>broadcast_tcp_packet</code> or <code>broadcast_udp_packet</code>. See <code>./server/main.c</code> for usage.</li>
<li>To handle a server message on the client, see <code>./client/handle_server_message.c</code></li>
<li>To handle a client message on the server, see <code>./server/handle_client_message.c</code></li>
<li>See <code>./fractal/core/fractal.h</code> for struct definitions.</li>
</ul>
<p>Of course, input must also be sent from client to server. This is handled in the form of SDL Events, which are retrieved in <code>./client/main.c</code> and handled in <code><a class="el" href="sdl__event__handler_8c.html" title="This file contains client-specific wrappers to low-level network.">sdl_event_handler.c</a></code>. These generally take the form of <code>fmsg</code>'s sent from client to server, over <code>UDP</code> for speed. We don't handle packet dropping, however, so sometimes the capslock and numlock will go out-of-sync. We use <code>sync_keyboard_state</code> to fix this, resyncing stateful keys every 50ms with an <code>fmsg</code>. This additionally handles the initial sync by-default.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
File Structure</h1>
<p><code>tree -I "share|sentry-native|lib|include|build*|CMakeFiles|docs|loading|cmake" -P "*.c" .</code></p>
<div class="fragment"><div class="line">./protocol</div>
<div class="line">├── client</div>
<div class="line">│   ├── audio.c &lt;- Handle and play audio packets</div>
<div class="line">│   ├── client_utils.c &lt;- cmdline options, among others</div>
<div class="line">│   ├── handle_server_message.c &lt;- Handle server fmsg&#39;s</div>
<div class="line">│   ├── main.c &lt;- SDL Event loop, receive and categorize packets as fmsg/audio/video</div>
<div class="line">│   ├── network.c &lt;- Functions to connect to server, and send_fmsg</div>
<div class="line">│   ├── sdl_event_handler.c &lt;- Handle SDL Events</div>
<div class="line">│   ├── sdl_utils.c &lt;- Set window icon, resize handler</div>
<div class="line">│   ├── sdlscreeninfo.c &lt;- Get monitor/window width/height functions</div>
<div class="line">│   └── video.c &lt;- Handle and render video packets</div>
<div class="line">├── fractal</div>
<div class="line">│   ├── audio</div>
<div class="line">│   │   ├── alsacapture.c &lt;- Capture Linux audio</div>
<div class="line">│   │   ├── audiodecode.c &lt;- AAC Decode Audio</div>
<div class="line">│   │   ├── audioencode.c &lt;- AAC Encode Audio</div>
<div class="line">│   │   └── wasapicapture.c &lt;- Capture Windows audio</div>
<div class="line">│   ├── clipboard</div>
<div class="line">│   │   ├── clipboard.c &lt;- Wrappers for get_clipboard/set_clipboard</div>
<div class="line">│   │   ├── clipboard_synchronizer.c &lt;- Multithreaded wrapper for get/set clipboard,</div>
<div class="line">|   |   |                               this is what actually gets used</div>
<div class="line">│   │   ├── mac_clipboard.c &lt;- Mac implementation of {get,set}_clipboard</div>
<div class="line">│   │   ├── win_clipboard.c &lt;- Windows implementation of {get,set}_clipboard</div>
<div class="line">│   │   └── x11_clipboard.c &lt;- Linux implementation of {get,set}_clipboard</div>
<div class="line">│   ├── core</div>
<div class="line">│   │   ├── fractal.c &lt;- Various helpers</div>
<div class="line">│   │   └── fractalgetopt.c &lt;- Cross-platform getopt</div>
<div class="line">│   ├── cursor</div>
<div class="line">│   │   ├── linuxcursor.c &lt;- get_current_cursor for Linux</div>
<div class="line">│   │   ├── peercursor.c &lt;- Helper functions for multiclient cursors</div>
<div class="line">│   │   └── windowscursor.c &lt;- get_current_cursor for Windows</div>
<div class="line">│   ├── input</div>
<div class="line">│   │   ├── input.c &lt;- Trigger keyboard/mouse press and sync, wraps raw input_driver.h calls</div>
<div class="line">|   |   ├── input_driver.h -&gt; The following three c files share this h file</div>
<div class="line">│   │   ├── winapi_input_driver.c &lt;- Windows keyboard/mouse-press code</div>
<div class="line">│   │   ├── uinput_input_driver.c &lt;- Linux uinput keyboard/mouse-press/touchpad code</div>
<div class="line">│   │   └── xtest_input_driver.c &lt;- Linux X11 keyoard/mouse-press code</div>
<div class="line">│   ├── network</div>
<div class="line">│   │   └── network.c &lt;- send udp/tcp/http packets.</div>
<div class="line">│   ├── utils</div>
<div class="line">│   │   ├── aes.c &lt;- Generic encrypt/decrypt of network packets</div>
<div class="line">│   │   ├── clock.c &lt;- Clock</div>
<div class="line">│   │   ├── color.c &lt;- RGB/YUV conversation, and other color helpers</div>
<div class="line">│   │   ├── json.c &lt;- JSON reader implementation</div>
<div class="line">│   │   ├── lodepng.c &lt;- LodePNG external dependency</div>
<div class="line">│   │   ├── logging.c &lt;- LOG_INFO/LOG_ERROR/etc, along with sentry breadcrumbs</div>
<div class="line">│   │   ├── mac_utils.c &lt;- Mac wrappers</div>
<div class="line">│   │   ├── mouse.c &lt;- Mutliclient cursor colors</div>
<div class="line">│   │   ├── png.c &lt;- Functions to encode/decode bitmap&#39;s as png&#39;s</div>
<div class="line">│   │   ├── rwlock.c &lt;- Implementation of a lock with one writer and many readers</div>
<div class="line">│   │   ├── sysinfo.c &lt;- Print RAM/OS/Memory/HDD etc for logging purposes</div>
<div class="line">│   │   ├── window_name.c &lt;- Linux Getter for the window name of the application</div>
<div class="line">│   │   └── windows_utils.c &lt;- Log-in past windows start screen</div>
<div class="line">│   └── video</div>
<div class="line">│       ├── dxgicapture.c &lt;- Capture screen using DXGI</div>
<div class="line">│       ├── nvidia-linux</div>
<div class="line">│       │   └── NvFBCUtils.c (NVDA Header)</div>
<div class="line">│       ├── transfercapture.c &lt;- Implements CPU or CUDA transfer of frame from device to encoder</div>
<div class="line">│       ├── videodecode.c &lt;- Decompress image using h264/h265</div>
<div class="line">│       ├── videoencode.c &lt;- Compress image using h264/h265</div>
<div class="line">│       ├── x11capture.c &lt;- Capture screen using X11</div>
<div class="line">│       └── x11nvidiacapture.c &lt;- Capture h264/h265 compressed screen with NvidiaCaptureSDK</div>
<div class="line">└── server</div>
<div class="line">    ├── client.c &lt;- Handle multiclient messages</div>
<div class="line">    ├── handle_client_message.c &lt;- Handle client fmsg&#39;s</div>
<div class="line">    ├── main.c &lt;- Initialite server, receive packets and pass to where it needs to go</div>
<div class="line">    ├── network.c &lt;- Networking code for multiclient</div>
</div><!-- fragment --><p>The above files are fairly static. If you add or remove a file, or change what a file does, please update this directory so we can keep track of it all!</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Development</h1>
<p>We use Cmake to compile, format and run tests on all systems, and also use Ninja on Windows for faster compilation. You first need to make sure Cmake 3.15 or higher is installed on your system, and install the latest version of Ninja as well if you are compiling on Windows (this may come with your Visual Studio, depending on how you configured it). We also use cppcheck to run static tests on the code, which you should install as well. If you are running on Windows, you also need to make sure the Nvidia CUDA Compiler, NVCC, is installed with version 11.0 or higher to compile our CUDA code.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Installation</h2>
<h3><a class="anchor" id="autotoc_md11"></a>
Linux</h3>
<p>If you are using a rolling release distro, e.g. Arch, then you can likely install the newest version using pacman or your distro's package manager. If you are running 20.04 the version in the Ubuntu package lists is fine. If you are running 18.04 the package lists only has 3.11. You can install the newest version from the developer with:</p>
<div class="fragment"><div class="line">sudo apt-get install apt-transport-https ca-certificates gnupg software-properties-common wget -y</div>
<div class="line">wget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc 2&gt;/dev/null | sudo apt-key add -</div>
<div class="line">sudo apt-add-repository &#39;deb https://apt.kitware.com/ubuntu/ bionic main&#39;</div>
<div class="line">sudo apt-get update</div>
<div class="line">sudo apt-get install cmake -y</div>
</div><!-- fragment --><p>You can install cppcheck via your package manager, e.g. <code>apt-get install cppcheck</code>.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
MacOS</h3>
<p>You can install both Cmake and cppcheck via Homebrew. You also need to have installed Xcode and installed the Xcode CLI tools, which you can install by running <code>xcode-select --install</code> in a terminal after having installed Xcode.</p>
<div class="fragment"><div class="line">brew install cmake cppcheck</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md13"></a>
Windows</h4>
<p>First you will have to install <a href="https://git-scm.com/downloads">gitbash</a>. You can install Cmake with the latest binaries <a href="https://cmake.org/download/">here</a>, and cppcheck with Chocolatey by running <code>choco install cppcheck --force</code>. This will ensure you can properly debug the protocol.</p>
<p>In order to compile it, you need to first install <a href="https://visualstudio.microsoft.com/downloads/">Microsoft Visual Studio Community 2019</a> and select <code>Desktop Development with C++</code> add-on in the installer. This will install different Visual Studio Command Prompts for different architectures. In order to compile the protocol, you need to make sure to be using x86_x64 Visual Studio Developer Command Prompt.</p>
<p>You also need to install the Nvidia CUDA Compiler, NVCC. You'll need <a href="https://developer.nvidia.com/cuda-11.0-download-archive?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exenetwork">Toolkit version 11.0</a>, which is latest at time of writing. If you have an Nvidia GPU, feel free to install all the components if you don't mind overwriting your display driver with whatever comes with the 11.0 release. If you don't have an Nvidia GPU, you have to be careful which components you install. At the Options page of the installer, choose the Custom Install. Don't install the Driver components or the Other components (it might be bad to overwrite your driver if you don't have an Nvidia GPU or you don't want the driver packaged with the 11.0 release). Meanwhile, under CUDA, you MUST install the Development→Compiler and Runtime→Library. Everything else is optional, though you might find the extra tools, samples, or visual studio integration useful.</p>
<p>After doing this, you might have to restart your terminal or IDE, after which you'll be able to build using CMake.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Building</h2>
<p>If you are on Linux Ubuntu, run <code>setup-linux-build-environment.sh</code> to install the system dependencies.</p>
<p>Downloading precompiled binaries from S3 will require the AWS CLI to be installed and set up on your machine. If you want to manually retrieve the binaries and retrieve the binaries by other means, run cmake with the <code>-D DOWNLOAD_BINARIES=OFF</code> option. Make sure you run cmake with this option <em>after</em> you have already downloaded your files from S3 into the proper locations.</p>
<h3><a class="anchor" id="autotoc_md15"></a>
Sentry</h3>
<p>The sentry-native SDK gets automatically built by our CMake build system.</p>
<p>To start the protocol with a given sentry configuration, use the <code>-e</code> argument, for instance with <code>.\FractalClient.exe -e prod &lt;IP&gt;</code>. See the output of <code>FractalClient.exe --help</code> for more details.</p>
<h3><a class="anchor" id="autotoc_md16"></a>
IDE</h3>
<p>We use CMake to build. If you are using VS code, VS or Clion, this is pretty easy to use. You need to either open the root repo folder as a project, or open the root <code>CMakelist.txt</code> as a project. On CLion and VS there is a menu to build at the top, on VS code you need the CMake extension and the build command is at the bottom. CMake currently has two types of builds, Debug and Release. You probably want to be building debug builds while developing, since they log more aggressively (Warning levels: Info and above).</p>
<p>Currently, we use the same compiler flags for Debug and Release because we distribute binaries with debug flags, to better troubleshoot errors and bugs.</p>
<p>The build target for client is "FractalClient" and the server is "FractalServer".</p>
<h3><a class="anchor" id="autotoc_md17"></a>
MacOS CLI</h3>
<p>You can simply run <code>cmake .</code> from the root folder, <code>/protocol/</code>, which will generate the makefiles. You can then run <code>make FractalClient</code> from the root folder, or cd into <code>/client</code> and run <code>make</code> to compile the MacOS client. The client will be in <code>/protocol/client/build64</code>.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
Linux CLI</h3>
<p>Install cmake and ccmake; ccmake is a TUI for configuring the build. From the root of the repo run <code>ccmake .</code>. You will initially see a blank screen because no cache has been built yet. Hit <code>c</code> to configure. This will populate the cache and show you a page with various settings. The setting you will likely care about is <code>CMAKE_BUILD_TYPE</code> which is one of <code>Debug</code> or <code>Release</code>.</p>
<p>Next hit <code>c</code> again to reconfigure with your possibly new settings, then hit <code>g</code> to generate the makefile. This makefile has all of the build targets, including FractalClient, FractalServer and all of our libraries. It also includes CMake targets such as clean, edit_cache and rebuild cache.</p>
<p>Only running <code>make</code> defaults to building FractalClient and FractalServer if you set both of these to ON in your configuration. GCC only supports one type of build at a time, so if you are currently building Release, but want to build Debug, you need to edit the cache and regenerate the makefile.</p>
<p>If you would like to keep your repo cleaner, make a build folder in <code>/protocol</code> and run <code>cmake</code> from there, e.g. <code>cd "build &amp; cmake ../."</code>. This way, you can just delete the contents of the build folder to start over.</p>
<h3><a class="anchor" id="autotoc_md19"></a>
Windows CLI</h3>
<p>To build on Windows, run the command <code>cmake -G "NMake Makefiles"</code> at the root directory from an x86_64 Visual Studio Developper Command Prompt, which is obtained through downloading Visual Studio. This tells CMake to generate NMake-style makefiles. Then, run <code>nmake</code> in either <code>/server</code> or <code>/client</code>, depending on which one you want to compile.</p>
<h3><a class="anchor" id="autotoc_md20"></a>
Further documentation</h3>
<p>We also use Doxygen in this repository. The Doxy file is <code>docs/Doxyfile</code>. To generate it, you should first install doxygen via your local package manager, and run <code>doxygen Doxyfile</code>. This will generate the docs and put them in <code>docs/html</code> and <code>docs/latex</code>. You can view the html docs by opening the index.html page with a web browser. We keep the docs gitignored to avoid clutter on the repository, since we don't publish them anywhere.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
CI &amp; CD</h1>
<h3><a class="anchor" id="autotoc_md22"></a>
Checks &amp; Tests</h3>
<p>These builds will also have <code>cppcheck</code> run against them which is a static analysis tool which can catch errors which compilers cannot, e.g. accessing uninitialized memory and other undefined behavior. Not everything it catches is critical, but it does indicate the possibility of unexpected behavior.</p>
<p>These builds will also (TODO) be tested against a live server VM. This workflow will spin up an Azure VM, upload the server build to it, and then use GitHub Actions VMs on Windows, MacOS and Linux Ubuntu as clients to connect and stream via the protocol for one minute. This will also occur nightly against the <code>dev</code> branch, but these builds will not be released (this can be removed once testing is stable and re-enabled on all commits).</p>
<p>To see the warnings in context go to the Actions tab, click on your PR/push that launched the action, select an OS it ran on and then select build. This expands the build log, where you can clearly see the warnings/errors generated.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
Continuous Integration</h2>
<p>For every push or PR, the code will be automatically linted via clang-format according to the <a href="#styling">styling</a> guidelines.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Styling</h1>
<h2><a class="anchor" id="autotoc_md25"></a>
clang-format</h2>
<p>For <code>.c</code> and <code>.h</code> files, we are formatting using the clang format <code>{BasedOnStyle: Google, IndentWidth: 4}</code>. You can download clang-format via the package manager for your respective OS:</p>
<div class="fragment"><div class="line">MacOS:</div>
<div class="line">brew install clang-format</div>
<div class="line"> </div>
<div class="line">Linux Ubuntu:</div>
<div class="line">apt-get install clang-format</div>
<div class="line"> </div>
<div class="line">Windows:</div>
<div class="line">choco install llvm --force</div>
</div><!-- fragment --><p>If using VSCode or Visual Studio, please set this up in your editor to format on save if possible (in Visual Studio, this is through the C/C++ extension settings, as well as the general 'Format on Save' setting/shortcut). Otherwise, please make sure to run your code through <code>clang</code> before commits. You can run it from the CLI by running <code>cmake . &amp;&amp; make clang-format</code>, on MacOS/Linux, or <code>cmake -G "NMake Makefiles" &amp;&amp; make clang-format</code>, on Windows.</p>
<p>We have <a href="https://pre-commit.com/">pre-commit hooks</a> with clang-format support installed on this project, which you can initialize by first installing pre-commit via <code>pip install pre-commit</code> and then running <code>pre-commit install</code> to instantiate the hooks for clang-format.</p>
<p>We also have a custom build target in the CMake 'clang-format' which will run with this style over all <code>.c</code> and <code>.h</code> files in <code>server/</code> <code>client/</code> and <code>fractal/</code>. You can call it by running <code>make clang-format</code>.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
clang-tidy</h2>
<p>Make sure your code is following code standards by running the script <code>./run-clang-tidy.sh</code>. The dependencies for each OS are listed below:</p>
<div class="fragment"><div class="line">MacOS:</div>
<div class="line"># set up clang-tidy and clang-apply-replacements</div>
<div class="line">brew install llvm</div>
<div class="line">ln -s &quot;$(brew --prefix llvm)/bin/clang-tidy&quot; &quot;/usr/local/bin/clang-tidy&quot;</div>
<div class="line">ln -s &quot;$(brew --prefix llvm)/bin/clang-apply-replacements&quot; &quot;/usr/local/bin/clang-apply-replacements&quot;</div>
<div class="line"> </div>
<div class="line">Linux Ubuntu:</div>
<div class="line">sudo apt install clang-tidy -y</div>
<div class="line"># clang-tidy and clang-apply-replacements-10 should come installed with clang</div>
<div class="line"> </div>
<div class="line">Windows:</div>
<div class="line"># Go to https://releases.llvm.org/download.html and install the pre-built LLVM binary. In the installation wizard, make sure to select &quot;add to path&quot;.</div>
</div><!-- fragment --><p>Running <code>./run-clang-tidy.sh</code> will find all code standard violations and give you the option to modify and accept or reject changes. Running './run-clang-tidy.sh -c' will find whether there are any code standard violations and exit with status 1 if there are (designed for CI usage).</p>
<p>If you want any lines to be exempted from the clang-tidy check, either place <code>// NOLINTNEXTLINE</code> in the line above or <code>// NOLINT</code> at the end of the line.</p>
<p>Macro constants will NOT be checked by this script because of the variety of implementations of <code>#define</code>. Please be sure to follow appropriate standards for <code>#define</code>s when committing code. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
